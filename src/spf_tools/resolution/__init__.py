"""
Resolution Management Tools for SPF Framework

This module provides tools for managing monitor resolution, detecting display scaling,
and fixing dimension mismatches that can occur with HiDPI/Retina displays.

Functions:
    check_monitors: Check and report monitor configurations
    detect_scaling: Detect display scaling factors
    generate_capture_fix: Generate resolution-corrected capture functions
    validate_projector_config: Validate ActionProjector configuration against monitors
"""

import mss
import numpy as np
import cv2
from typing import Dict, Tuple, Optional, List
from pathlib import Path


def check_monitors() -> Dict[str, Dict]:
    """
    Check and report all monitor configurations.

    Returns:
        Dictionary containing monitor information for each detected monitor
    """
    monitor_info = {}

    try:
        with mss.mss() as sct:
            for i, monitor in enumerate(sct.monitors):
                if i > 0:  # Skip monitor 0 (all monitors combined)
                    # Capture test screenshot to detect scaling
                    screenshot = sct.grab(monitor)
                    img = np.array(screenshot)

                    # Calculate scaling ratios
                    width_ratio = img.shape[1] / monitor['width']
                    height_ratio = img.shape[0] / monitor['height']

                    monitor_info[f"monitor_{i}"] = {
                        "index": i,
                        "logical_width": monitor['width'],
                        "logical_height": monitor['height'],
                        "physical_width": img.shape[1],
                        "physical_height": img.shape[0],
                        "width_scaling": width_ratio,
                        "height_scaling": height_ratio,
                        "is_hidpi": width_ratio > 1.1 or height_ratio > 1.1,
                        "position": {
                            "left": monitor['left'],
                            "top": monitor['top'],
                            "right": monitor['left'] + monitor['width'],
                            "bottom": monitor['top'] + monitor['height']
                        }
                    }

    except Exception as e:
        print(f"Error checking monitors: {e}")

    return monitor_info


def detect_scaling(monitor_index: int = 1) -> Tuple[float, float]:
    """
    Detect scaling factors for a specific monitor.

    Args:
        monitor_index: Monitor index to check (1=primary)

    Returns:
        Tuple of (width_scaling, height_scaling) factors
    """
    try:
        with mss.mss() as sct:
            if monitor_index >= len(sct.monitors):
                monitor_index = 1

            monitor = sct.monitors[monitor_index]
            screenshot = sct.grab(monitor)
            img = np.array(screenshot)

            width_scaling = img.shape[1] / monitor['width']
            height_scaling = img.shape[0] / monitor['height']

            return width_scaling, height_scaling

    except Exception as e:
        print(f"Error detecting scaling: {e}")
        return 1.0, 1.0


def generate_capture_fix(output_path: Optional[str] = None) -> bool:
    """
    Generate a resolution-corrected capture function based on detected scaling.

    Args:
        output_path: Path to save the generated fix (default: current directory)

    Returns:
        True if fix was generated successfully, False otherwise
    """
    try:
        # Detect scaling for primary monitor
        width_scaling, height_scaling = detect_scaling(1)

        if abs(width_scaling - 1.0) < 0.1 and abs(height_scaling - 1.0) < 0.1:
            print("No scaling detected, fix not needed")
            return False

        # Generate the fix code
        fix_code = f'''#!/usr/bin/env python3
"""
Auto-generated resolution fix for {width_scaling:.2f}x display scaling
Generated by SPF Tools resolution management system
"""

import cv2
import numpy as np
import mss
from typing import Optional


def capture_screen_fixed(monitor_index: int = 1) -> np.ndarray:
    """
    Capture screen with automatic resolution correction for HiDPI displays.

    Args:
        monitor_index: Monitor to capture (1=primary, 2=secondary, etc.)

    Returns:
        RGB image array with dimensions matching logical resolution

    Raises:
        RuntimeError: If screen capture fails
    """
    try:
        with mss.mss() as sct:
            if monitor_index >= len(sct.monitors):
                print(f"Warning: Monitor index {{monitor_index}} out of range, using primary (1)")
                monitor_index = 1

            monitor = sct.monitors[monitor_index]
            screenshot = sct.grab(monitor)
            img = np.array(screenshot)
            img_rgb = cv2.cvtColor(img, cv2.COLOR_BGRA2RGB)

            # Detect actual scaling
            actual_width_scaling = img_rgb.shape[1] / monitor['width']
            actual_height_scaling = img_rgb.shape[0] / monitor['height']

            # Apply scaling correction if needed
            if actual_width_scaling > 1.1 or actual_height_scaling > 1.1:
                corrected_img = cv2.resize(
                    img_rgb,
                    (monitor['width'], monitor['height']),
                    interpolation=cv2.INTER_AREA
                )
                return corrected_img
            else:
                return img_rgb

    except Exception as e:
        raise RuntimeError(f"Screen capture failed: {{e}}")


def capture_screen_raw(monitor_index: int = 1) -> np.ndarray:
    """
    Capture screen at full physical resolution without scaling correction.

    Args:
        monitor_index: Monitor to capture

    Returns:
        RGB image array at full physical resolution

    Raises:
        RuntimeError: If screen capture fails
    """
    try:
        with mss.mss() as sct:
            if monitor_index >= len(sct.monitors):
                monitor_index = 1

            monitor = sct.monitors[monitor_index]
            screenshot = sct.grab(monitor)
            img = np.array(screenshot)
            return cv2.cvtColor(img, cv2.COLOR_BGRA2RGB)

    except Exception as e:
        raise RuntimeError(f"Raw screen capture failed: {{e}}")


if __name__ == "__main__":
    # Test the generated functions
    print("Testing resolution-corrected capture functions...")

    try:
        # Test corrected capture
        img_fixed = capture_screen_fixed(1)
        print(f"Corrected capture dimensions: {{img_fixed.shape[1]}}x{{img_fixed.shape[0]}}")

        # Test raw capture
        img_raw = capture_screen_raw(1)
        print(f"Raw capture dimensions: {{img_raw.shape[1]}}x{{img_raw.shape[0]}}")

        # Save test images
        cv2.imwrite("test_capture_fixed.jpg", cv2.cvtColor(img_fixed, cv2.COLOR_RGB2BGR))
        cv2.imwrite("test_capture_raw.jpg", cv2.cvtColor(img_raw, cv2.COLOR_RGB2BGR))

        print("Test images saved as test_capture_fixed.jpg and test_capture_raw.jpg")

    except Exception as e:
        print(f"Test failed: {{e}}")
'''

        # Write the fix file
        if output_path is None:
            output_path = "capture_screen_fixed.py"

        with open(output_path, 'w') as f:
            f.write(fix_code)

        print(f"Resolution fix generated: {output_path}")
        print(f"Detected scaling: {width_scaling:.2f}x (width), {height_scaling:.2f}x (height)")
        return True

    except Exception as e:
        print(f"Error generating fix: {e}")
        return False


def validate_projector_config(projector_width: int, projector_height: int) -> Dict[str, bool]:
    """
    Validate ActionProjector configuration against actual monitor setup.

    Args:
        projector_width: Width configured in ActionProjector
        projector_height: Height configured in ActionProjector

    Returns:
        Dictionary containing validation results
    """
    results = {
        "matches_logical": False,
        "matches_physical": False,
        "scaling_detected": False,
        "recommended_action": "unknown"
    }

    try:
        monitor_info = check_monitors()

        if not monitor_info:
            results["recommended_action"] = "no_monitors_detected"
            return results

        # Check primary monitor (monitor_1)
        primary = monitor_info.get("monitor_1", {})

        if not primary:
            results["recommended_action"] = "no_primary_monitor"
            return results

        # Check against logical dimensions
        if (primary["logical_width"] == projector_width and
            primary["logical_height"] == projector_height):
            results["matches_logical"] = True

        # Check against physical dimensions
        if (primary["physical_width"] == projector_width and
            primary["physical_height"] == projector_height):
            results["matches_physical"] = True

        # Check if scaling is detected
        results["scaling_detected"] = primary["is_hidpi"]

        # Determine recommended action
        if results["matches_physical"]:
            results["recommended_action"] = "config_correct_physical"
        elif results["matches_logical"]:
            if results["scaling_detected"]:
                results["recommended_action"] = "consider_physical_dimensions"
            else:
                results["recommended_action"] = "config_correct_logical"
        else:
            if results["scaling_detected"]:
                results["recommended_action"] = "update_to_physical_dimensions"
            else:
                results["recommended_action"] = "update_to_logical_dimensions"

    except Exception as e:
        print(f"Error validating projector config: {e}")
        results["recommended_action"] = "validation_error"

    return results


def print_monitor_summary() -> None:
    """Print a formatted summary of monitor configuration."""
    print("\n=== MONITOR CONFIGURATION SUMMARY ===")

    monitor_info = check_monitors()

    if not monitor_info:
        print("‚ùå No monitors detected")
        return

    for name, info in monitor_info.items():
        print(f"\n{name.upper()}:")
        print(f"  Logical resolution: {info['logical_width']}x{info['logical_height']}")
        print(f"  Physical resolution: {info['physical_width']}x{info['physical_height']}")
        print(f"  Scaling factor: {info['width_scaling']:.2f}x")
        print(f"  HiDPI display: {'Yes' if info['is_hidpi'] else 'No'}")
        print(f"  Position: ({info['position']['left']}, {info['position']['top']}) to "
              f"({info['position']['right']}, {info['position']['bottom']})")


__all__ = [
    "check_monitors",
    "detect_scaling",
    "generate_capture_fix",
    "validate_projector_config",
    "print_monitor_summary"
]
